- > 前言这不是教材也不是lecture note，可能会有些错误地方，毕竟是出于兴趣写的。所以请见谅。当然我会尽量写的稍微正确一点，我会把所有的reference写在最后
- > 本文从头到尾基本上是在一个Unix-Compatible的Linux上运行的，所以你可以把它看作是一个同时面向了MacOS的文章。
- > 请注意本文与机器架构无关，仅和操作系统实现有关
- > 本文的阅读时间：
-
- 学编程的应该都知道有这么个语言叫做C语言，如果你学个那么一开始的每个人的起手式应该是printf一串字符串了。
- 下面是一个最简单的C语言程序， 简单来说你要有一个程序的**入口**起点叫做main，你引入了一个头文件叫做stdio.h，然后在里面调用了一个C语言库函数叫做printf，然后就能愉快的打印了你想要的东西了。
-
- ```C
  #include <stdio.h>
  #include <stdlib.h>
  
  int main(int argc, char *argv[]){
    printf("Hello world!\n");
    return 0;
  }
  ```
- 然后所有的教程都会告诉你，你需要把这个文件或者叫做**源文件**喂给一个叫做**编译器**的东西，然后ta负责把你的源文件进行加工组装，然后生成一个能够在你的系统上运行的终端程序了。
- 使用Linux, 你只需要使用GNU C Compiler (GNU C 编译器) 然后运行这个指令你就会在当前目录下面找到。
- ```console
  gcc hello_world.c -o hello_world
  ```
- 在此之后，你就可以在命令行里面输入
- ```console
  ./hello_world
  ```
- 然后你就有了
- ```console
  Hello world!
  ```
- **好耶**！
- ---
- ### 一些超出常规但是非常合理的疑问
- 你的确打出了Hello world，然后你就继续看你的**谭浩强**了，但是不知道聪明的你有没有想过...
- > **为什么这个文件能被正确的生成出来？**
- >**为什么这个文件能够被正确的执行？系统是怎么执行这个玩意的？**
- > **为什么这个Hello world输入到了执行的终端里，为什么没有跑到外边或者跑到屏幕上去，~甚至跑到你的高数卷子上面去？**
- > 凭什么main函数的声明是这个样子 为什么不是 void main(int foo, char bar, int *abc) 这种东西
- 当你学的更多的时候，比如你可能会想 ...
- > **这个printf的定义在哪里呢？为什么我点进那个stdio.h里面就一个extern 然后就没了？**
- > **好好好，这个Hello World对应一个字符串数据，那么这个数据是怎么从程序中读到终端上去的？**
- > 按照道理来说Hello World和语句应该翻译成不一样的东西以及格式，那么他们是怎么分开的又是怎么分开的？
- ---
- 好好好，你可能已经被我搞晕了，我将在以下文章里面阐述清楚这些问题。
- 现在我们可能就觉得这个Hello World没有那么的简单了，但既然有了这些问题后，不妨让我们回到最初的美好，看看上古时期的抽象计算机是怎么运行程序的。
- ## 不断运算的机器
- 说到计算机呢那么我们就不得不提到计算机的最经典也是沿用至今的架构 —— 冯诺依曼架构。
- 下面是冯诺依曼架构的简要构成图
- ![Von Neumann Architecture Diagram - Computer Science GCSE](http://computerscience.gcse.guru/wp-content/uploads/2016/04/Von-Neumann-Architecture-Diagram.jpg)
- 这个是冯老爷子最初的构想，一个输入设备，一个可供访问的足够大的中间存储单元(memory)，一个中央处理单元（包括控制单元，计算单元，以及一些保存计算中间状态的寄存器）以及一个输出设备，就是这么简单。
- 控制单元负责控制一切的流程以及交互，包括控制你的输入，负责与存储设备沟通，以及将内容进行输出。计算单元，顾名思义很简单，就是计算，就是做运算，从设置好的寄存器读入状态并计算状态输出到对应的目标寄存器。对，在冯诺以曼架构中，所有的计算都是要在寄存器上进行完成，其实如果你学过数字电路，你就可能学过一个概念，一个加法器对应一个位宽，而这个需要的位宽就在我们给定的寄存器上进行了定义，在一个时钟周期内，我们即可计算出一个给定位宽的运算加法。
- 上述我们所说的**寄存器**，都称为**通用寄存器**，何为通用，就是他们都可以作为运算的操作数，包括整数与浮点数乘法，除法，加法，减法以及简单向量运算。当然还有一类专门寄存器，是CPU厂商专门用来设置特定功能或者判定状态的，当然在这个我们最简化的例子中我们就来讲讲PC寄存器。
- PC寄存器或者我们通常讲的叫做PC指针，你可能在C语言中学过指针，这里的指针也是参照相同的意思，代表着内存的某一块区域的地址，因为指令是存在在内存里的，所以我们需要知道CPU执行的时候是需要知道从哪里去要指令，如果那个指令找不到了，那么CPU就会自动地停下来。当指令结束完了，如果没有如同if一样的跳转的话，CPU就会默认的自己增加自己的PC然后不断的执行下去。
- 这就是我们在计算机系统基础中所说的最简易的运行模型
- > 取指 - 译码 - 执行 - 更新PC 详见NJU ICS Project Assignment P2.1 [^1]
- 现在我们有了内存，CPU，输出设备，当然还有内存里上的程序，那如果我们能想办法把程序读到内存里面，就可以执行并打印我们的Hello World，是吗？
- 很显然，这个古老的模型还是没有办法回答很多的细节
	- 首先也是很明显我们这里是有点偷懒的，因为和以前50-60年代的运行的程序不一样，我们运行的程序比如`Hello World`一开始肯定是在你的存储设备里的，那么是怎么是从存储设备里就进到了我们的内存里呢？
	- 其次，很显然我们程序所需要的运算数据（比如那个Hello World）这个数据肯定是和程序的代码数据肯定是分开的，否则如果混起来，我们肯定是不希望我们的字符串被当作代码一样而执行。那么我们肯定需要这么一个阶段，便是将程序的不同部分的数据加载到不同的地方，那么这么是怎么发生的？
	- 最后是输出设备，早期的输出设备很显然只有一台打印机，但是当代我们的输出设备早已经非常非常多了，那我们是如何来决定这个输出设备的呢？
- 我们知道这些事情都是我们使用的操作系统帮我们完成的，那么就让我们把目光回到操作系统的身上，看看它为我们准备哪些机制去运行这一个程序。
- ## 操作一下？
- 操作系统，我们来借用一下wikipedia上面的定义
- > An **operating system** (**OS**) is [system software](https://en.wikipedia.org/wiki/System_software) that manages [computer hardware](https://en.wikipedia.org/wiki/Computer_hardware) and [software](https://en.wikipedia.org/wiki/Software) resources, and provides common [services](https://en.wikipedia.org/wiki/Daemon_(computing)) for [computer programs](https://en.wikipedia.org/wiki/Computer_program).
- 即操作系统管理计算机的硬件和软件资源来为计算机程序提供基础的服务。
- 早期的计算机系统很简单，就跟我们说的冯诺以曼架构的一样，系统管理员把程序（磁带）物理的塞进机器里面，然后机器就一股脑的把磁带里的东西自动的写进内存里，然后就开始运行了。但是后面人们就想这样做也太麻烦了，首先是我们需要手动的程序载入进去，然后等待完成，再载入下一个程序。我们能不能做到顺序地让机器就这样不断的跟水流一下哗哗地流下来，不断地运行呢？
- 这个就是批处理系统的概念，那这个概念的核心就是需要一个后台程序不断地去加载程序，这个后台程序只需要做一件事情，那就是加载程序！
- 乾，这也太简单了吧！你可能会这么想，但这的确是操作系统的雏形，就是一个简单的批处理系统。
- 那为什么这个批处理系统又不断向前演化变成管理计算机资源的使者了呢，你可以想想假如每一个我们的程序都能控制我们的硬件资源，那么这个程序如果是恶意的话，那他可以直接掌控我们计算机的控制权，并且直接杀死这个后台程序。哦哦，我们肯定是不想要那么干的，所以这个后台程序需要更高的权限并且需要比其他的程序更加`公平`那么一点，所以我们就有了权限的这样的一个概念，即`内核权级`和`用户权级`，当普通的程序需要请求一定资源的时候（比如在我们的Hello World的程序中需要想屏幕输出信息的时候），我们就需要让这个后台程序，帮我们把信息输出到屏幕上，而不是自己胡乱输出。
- 但这又带出了一个问题，如果普通程序需要让我们的这个操作系统代替它执行一些命令的话，那么很显然我们的机器需要有这样的一个功能，即让出目前执行的程序的控制权，并对当前的状态进行保存，然后让操作系统重新上位执行，执行完毕后再恢复回去。这一个过程就是我们耳熟能详的名字——上下文切换（Context Switch）。正如同我们在做阅读理解时候所需要的上下文，程序的上下文就是上述我们所讲的冯诺以曼架构中的CPU的寄存器，当我们从一个上下文切换到另外一个上下文，也就是完成了程序运行的切换。
- 另一个需要考虑的是，我们的程序是怎么知会CPU来进行所谓的上下文切换来行使内核权级的操作的呢？CPU的设计者都会准备这样的一个寄存器以及一条指令，当CPU执行到这样的一条指令的时候，CPU就中断现在的程序执行，从那一个寄存器中读入新的PC地址，并将PC指针设置成那个寄存器的地址，一般来说这个寄存器的地址都是操作系统的代码地址，当操作系统完成了用户程序所需要的操作后，又将PC返回到原来的用户程序。这样的一个操作，我们就叫做`用户中断`，顾名思义中断当前程序的动作，而发出的内核权级的操作的这一过程，被称作`系统调用`。
- 在Unix系统中，每一个程序的执行都充满了系统调用，如果你想知道你的程序到底调用了哪些系统调用的话，你可以使用`strace`这个工具帮助你。
- ```shell
  strace ./hello_world
  ```
- ```
  execve("./hello_world", ["./hello_world"], 0x7ffdcf6566f0 /* 77 vars */) = 0
  brk(NULL)                               = 0x558a93170000
  access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
  openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
  newfstatat(3, "", {st_mode=S_IFREG|0644, st_size=119922, ...}, AT_EMPTY_PATH) = 0
  mmap(NULL, 119922, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f285b354000
  close(3)                                = 0
  openat(AT_FDCWD, "/lib64/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
  read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260@\2\0\0\0\0\0"..., 832) = 832
  pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
  newfstatat(3, "", {st_mode=S_IFREG|0755, st_size=1822808, ...}, AT_EMPTY_PATH) = 0
  mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f285b352000
  pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
  mmap(NULL, 1850224, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f285b18e000
  mmap(0x7f285b1b0000, 1318912, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x22000) = 0x7f285b1b0000
  mmap(0x7f285b2f2000, 335872, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x164000) = 0x7f285b2f2000
  mmap(0x7f285b344000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b6000) = 0x7f285b344000
  mmap(0x7f285b34a000, 31600, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f285b34a000
  close(3)                                = 0
  mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f285b18c000
  arch_prctl(ARCH_SET_FS, 0x7f285b353680) = 0
  set_tid_address(0x7f285b353950)         = 319254
  set_robust_list(0x7f285b353960, 24)     = 0
  rseq(0x7f285b353fa0, 0x20, 0, 0x53053053) = 0
  mprotect(0x7f285b344000, 16384, PROT_READ) = 0
  mprotect(0x558a92ac3000, 4096, PROT_READ) = 0
  mprotect(0x7f285b3a0000, 8192, PROT_READ) = 0
  prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
  munmap(0x7f285b354000, 119922)          = 0
  newfstatat(1, "", {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x4), ...}, AT_EMPTY_PATH) = 0
  getrandom("\xf0\xd4\xed\x82\xe6\xf3\xce\x78", 8, GRND_NONBLOCK) = 8
  brk(NULL)                               = 0x558a93170000
  brk(0x558a93191000)                     = 0x558a93191000
  write(1, "hello world\n", 12hello world
  )           = 12
  exit_group(0)                           = ?
  +++ exited with 0 +++
  ```
- >你可能被这一大堆的系统调用，吓晕了，但是不要着急，我们接下去回来慢慢剖析。
- 目前我们介绍了最简单的操作系统的一些概念知识，已经足够让我们应付接下去的内容了。
- > 操作系统的规约是一条又一条的软件硬件的协同合作，如同上文我们所讲的系统调用，都属于操作系统的约定，遵守约定可以说是完善系统设计的一个法则，现今比较出名的操作系统规约就是Posix规范。
- 所以下面我将解决第一个问题——程序是怎么读到内存里，以及是怎么分布开来的？
- ## 古希腊掌管块设备的神 --- 文件系统
- ### 简单的抽象
- ```shell
  ./hello_world
  ```
- 当我们尝试运行这样的一个程序的时候，首先肯定是要让操作系统知道这个程序到底存在在我们硬盘的哪个地方。早期的程序存放的地方很简单，无非就是一个打孔机，一块磁带，或者是一个软盘。我们的机器事实上不太需要干一些复杂的东西，只要如实地从存储介质中读入数据到自己的内存里，就可以直接运行了。
- 但是随着存储设备的增大，人们不满足将一个程序只存在一块软盘里，他们想要一个存储设备就能够存储很多很多的程序，这样以来文件系统就孕育而生了。文件系统就是操作系统内部的这样一个模块，让操作系统方便的查询我们的硬盘中的内容。
- 在操作系统的世界里，我们的存储设备被统一地看作一个**块设备**，所谓块设备就是数据是通过一个块一个块来存储的，由于硬盘相比于我们的内存实在是太大了，我们一个字节一个字节来进行管理显然是不现实，所以文件系统的以及硬件设备的设计者就想了一个很好的idea，控制**粒度**。如果你玩过minecraft就知道，minecraft的最小生成粒度就是一个区块，物理文件系统也是类似的，以一个一个的块来记录实际的数据。
- 那么什么是`文件`呢，在这里程序是文件，因为很明显他能执行嘛，你可能会拓展开来有不同的文件，然后我们可能会用不同的手段去操作他们。一个文件归根结底就是一大串的字节，古早的文件系统开发者想要将文件分类，也就是一个萝卜一个坑，但是这样就造成了很多问题，比如当我想用一个程序去生成另外一个程序的时候，我该用什么程序去打开呢？所以Unix的设计者用了一个比较简单的想法，一个有界的或者是无界的字节流的抽象，这样来一段内存可以是一个文件，一个程序的输出它也可以成为一个只读文件然后输入到另外一个程序当中。
- 一个文件系统所要设计的东西会很多，但是它的功能其实是比较单一的，也就是维护一个文件名到一系列文件实体块的映射，操作系统通过文件系统这样的一个模块来维护存储设备上的状态，这就是文件系统的雏形。
- 虽然现代的文件系统干的事情原超你的想象，他可以混合存储，甚至可以做数据的有效性校验，但是归根结底的说设计他们的第一目标还是较为明确的，快速且正确地管理文件的增删改查就是我们的设计初衷。
- ### 虚拟文件系统
- > 万物都是文件
- 在本文中，我们都没有提及Unix系统，那么现在我们就来探讨一下unix的文件系统的设计。Unix的主要开发者
- Ken Thompson在他的所著Linux
- ## 程序的组成 --编译器
- ## 加载器
- 首先我们需要确定一点，就是
- ## 一个程序运行的生命周期
- 我们终于成功的将hello_world加载到了内存里，我的天啊，这才是第一步呢？
- 那么接下来我们将正式地解剖这么一个小小的printf了，那么自然而然我们需要问第一件事情就是，我们的这个printf的代码到底在哪里？
- 我们通过上一小节
- ## 从电报打字机到虚拟终端
- 最后的最后，我们来回答这么一个问题，我们的Linux操作系统是怎么知道把我们程序的输出，输出到我们的屏幕上面的。我们现在知道我们将
- ## Nvidia fxxk you？
- [^1]: [南京大学计算机系统基础课程实验 PA2.1](https://nju-projectn.github.io/ics-pa-gitbook/ics2022/PA2.html)